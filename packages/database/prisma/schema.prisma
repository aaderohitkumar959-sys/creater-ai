generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                             String         @id @default(cuid())
  name                           String?
  email                          String         @unique
  emailVerified                  DateTime?
  image                          String?
  role                           Role           @default(USER)
  isBanned                       Boolean        @default(false)
  bannedUntil                    DateTime?
  dailyMessageCount              Int            @default(0)
  lastMessageDate                DateTime?
  stripeCustomerId               String?        @unique
  loginStreak                    Int            @default(0)
  lastDailyRewardClaimed         DateTime?
  createdAt                      DateTime       @default(now())
  updatedAt                      DateTime       @updatedAt
  accounts                       Account[]
  appealsReviewed                Appeal[]       @relation("AppealsReviewed")
  appeals                        Appeal[]
  auditLogs                      AuditLog[]
  CoinWallet                     CoinWallet?
  conversations                  Conversation[]
  Creator                        Creator?
  Payment                        Payment[]
  reports                      Report[]       @relation("Report_reportedUser")
  reportsMade                    Report[]       @relation("ReportsMade")
  reportsReviewed                Report[]       @relation("ReportsReviewed")
  sessions                       Session[]
  subscription                   Subscription?
  bansIssued                     UserBan[]      @relation("BansIssued")
  bans                           UserBan[]      @relation("UserBans")
  violations                     Violation[]
  memories                       Memory[]
  AIRequest                      AIRequest[]
  paidMessageCredits             Int            @default(0)
  pushSubscriptions              PushSubscription[]
  lastLoginDate                  DateTime?
  metadata                       Json?
  messages                       Message[]
}

model RedemptionCode {
  id        String   @id @default(cuid())
  code      String   @unique
  amount    Int      @default(500)
  isUsed    Boolean  @default(false)
  userId    String?
  usedAt    DateTime?
  createdAt DateTime @default(now())

  @@index([code])
}

model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  createdAt    DateTime @default(now())
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Creator {
  id        String    @id @default(uuid())
  userId    String    @unique
  bio       String?
  earnings  Int       @default(0)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  personas  Persona[]
}

model Persona {
  id            String         @id @default(uuid())
  creatorId     String
  name          String
  avatarUrl     String?
  description   String?
  personality   Json?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  category      String?
  isFeatured    Boolean        @default(false)
  conversations Conversation[]
  creator       Creator        @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  trainingData  TrainingData[]
  memories      Memory[]
}

model TrainingData {
  id        String       @id @default(uuid())
  personaId String
  type      TrainingType
  content   String
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  persona   Persona      @relation(fields: [personaId], references: [id], onDelete: Cascade)
}

model Conversation {
  id        String    @id @default(uuid())
  userId    String
  personaId String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  persona   Persona   @relation(fields: [personaId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages  Message[]

  @@unique([userId, personaId])
}

model Message {
  id             String       @id @default(uuid())
  conversationId String
  sender         Role
  content        String
  coinCost       Int          @default(2)
  isDeleted      Boolean      @default(false)
  userId         String?
  createdAt      DateTime     @default(now())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User?         @relation(fields: [userId], references: [id])
  reports        Report[]
}

model CoinWallet {
  id           String            @id @default(uuid())
  userId       String            @unique
  balance      Int               @default(0)
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt
  transactions CoinTransaction[]
  user         User              @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model CoinTransaction {
  id          String          @id @default(uuid())
  walletId    String
  type        TransactionType
  amount      Int
  description String?
  metadata    Json?
  createdAt   DateTime        @default(now())
  wallet      CoinWallet      @relation(fields: [walletId], references: [id], onDelete: Cascade)
}

model CoinPack {
  id         String   @id @default(uuid())
  name       String
  coins      Int
  bonusCoins Int      @default(0)
  priceUSD   Float
  priceINR   Float
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model Payment {
  id            String          @id @default(uuid())
  userId        String
  provider      PaymentProvider
  amount        Float
  currency      String
  status        PaymentStatus   @default(PENDING)
  providerTxnId String?
  coinPackId    String?
  coinsGranted  Int?
  metadata      Json?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  user          User            @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Report {
  id                           String       @id @default(uuid())
  reporterId                   String
  reportedUserId                   String?
  messageId                    String?
  type                         ReportType
  category                     String
  reason                       String
  details                      String?
  conversationId               String?
  actionTaken                  String?
  status                       ReportStatus @default(PENDING)
  reviewedBy                   String?
  reviewNote                   String?
  createdAt                    DateTime     @default(now())
  reviewedAt                   DateTime?
  reported                         User?        @relation("Report_reportedUser", fields: [reportedUserId], references: [id])
  message                          Message?     @relation(fields: [messageId], references: [id])
  reporter                     User         @relation("ReportsMade", fields: [reporterId], references: [id])
  reviewer                     User?        @relation("ReportsReviewed", fields: [reviewedBy], references: [id])

  @@index([status, createdAt])
  @@index([reportedUserId])
}

model Violation {
  id         String            @id @default(uuid())
  userId     String
  type       ViolationType
  severity   Severity
  content    String?
  categories String[]
  action     ModerationAction?
  note       String?
  createdAt  DateTime          @default(now())
  user       User              @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
}

model UserBan {
  id        String    @id @default(uuid())
  userId    String
  type      BanType
  reason    String
  bannedBy  String
  expiresAt DateTime?
  appealId  String?   @unique
  createdAt DateTime  @default(now())
  appeal    Appeal?   @relation(fields: [appealId], references: [id])
  banner    User      @relation("BansIssued", fields: [bannedBy], references: [id])
  user      User      @relation("UserBans", fields: [userId], references: [id])

  @@index([userId, expiresAt])
}

model Appeal {
  id         String       @id @default(uuid())
  userId     String
  banId      String       @unique
  reason     String
  status     AppealStatus @default(PENDING)
  reviewedBy String?
  reviewNote String?
  createdAt  DateTime     @default(now())
  reviewedAt DateTime?
  reviewer   User?        @relation("AppealsReviewed", fields: [reviewedBy], references: [id])
  user       User         @relation(fields: [userId], references: [id])
  ban        UserBan?

  @@index([status, createdAt])
}

model AuditLog {
  id         String      @id @default(uuid())
  userId     String
  action     AuditAction
  entityType String
  entityId   String
  metadata   Json?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime    @default(now())
  user       User        @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
  @@index([entityType, entityId])
}

model AnalyticsEvent {
  id        String   @id @default(uuid())
  userId    String?
  event     String
  metadata  Json?
  createdAt DateTime @default(now())

  @@index([event, createdAt])
}

enum TrainingType {
  TEXT
  FILE
}

enum TransactionType {
  PURCHASE
  SPEND
  EARN
  REFUND
  WITHDRAWAL
}

enum PaymentProvider {
  STRIPE
  RAZORPAY
  PAYPAL
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum ReportType {
  MESSAGE
  USER
  PERSONA
}

enum ReportStatus {
  PENDING
  REVIEWING
  RESOLVED
  DISMISSED
  APPROVED
  REJECTED
  UNDER_REVIEW
  UNDER_INVESTIGATION
}

enum ViolationType {
  HATE_SPEECH
  HARASSMENT
  SEXUAL_CONTENT
  VIOLENCE
  SELF_HARM
  SPAM
  ILLEGAL
  MISINFORMATION
  OTHER
}

enum Severity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum ModerationAction {
  WARNING
  TEMP_BAN
  PERM_BAN
}

enum BanType {
  CHAT
  PLATFORM
}

enum AppealStatus {
  PENDING
  APPROVED
  REJECTED
}

enum AuditAction {
  USER_BANNED
  USER_UNBANNED
  REPORT_CREATED
  REPORT_REVIEWED
  VIOLATION_LOGGED
  APPEAL_CREATED
  APPEAL_APPROVED
  APPEAL_REJECTED
}

enum Role {
  USER
  ADMIN
  CREATOR
  MODERATOR
}

model Subscription {
  id                   String   @id @default(uuid())
  userId               String   @unique
  tier                 String   @default("FREE")
  plan                 String   @default("FREE")
  status               String   @default("INACTIVE")
  stripeSubscriptionId String?  @unique
  stripeCustomerId     String?
  currentPeriodStart   DateTime @default(now())
  currentPeriodEnd     DateTime @default(now())
  endDate              DateTime @default(now())
  cancelAtPeriodEnd    Boolean  @default(false)
  canceledAt           DateTime?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Memory {
  id             String   @id @default(uuid())
  userId         String
  personaId      String
  type           String
  content        String
  importance     Int      @default(1)
  createdAt      DateTime @default(now())
  lastAccessedAt DateTime @default(now())
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  persona        Persona  @relation(fields: [personaId], references: [id], onDelete: Cascade)

  @@index([userId, personaId])
}

model AIRequest {
  id         String   @id @default(uuid())
  userId     String
  personaId  String
  provider   String
  tokensUsed Int
  costUSD    Decimal  @db.Decimal(10, 6)
  latencyMs  Int
  success    Boolean
  createdAt  DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id])
}

model PushSubscription {
  id        String   @id @default(uuid())
  userId    String
  endpoint  String   @unique
  p256dh    String
  auth      String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}
